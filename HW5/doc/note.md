# 关于HW5框架的一些问题和要点

* 自相交是光线追踪中的一个常见问题。当光线从一个物体的表面反射或折射时，由于浮点数的精度问题，计算出的新光线可能会立即与该物体的表面相交，这就是所谓的自相交。为了避免这个问题，通常会在计算新光线的起点时，向法线的方向或反方向偏移一点。这个偏移量通常是一个很小的值，比如框架代码中的 scene.epsilon。这样做可以确保新光线的起点在物体的表面之外，从而避免自相交。但是，这个偏移量不能太大，否则可能会导致新光线错误地与其他物体相交.
* 关注浮点数，只能说。每次不小心没有把int转换成float，最后的结果都会超乎想象。



## 关于(whitted-style)光线追踪和光栅化的想法

* 对于光栅化，我们一般都是采用三角形mesh来描述空间中的几何体。个人理解：光栅化需要进行多次变换，最终变成屏幕坐标，那就需要一个变换的对象，这个对象就用三角形的顶点，因为三角形本身更稳定，性质也比较简单。例如对于一个球体，如果只给出圆心坐标和半径，直接对其整体进行变换，在最后光栅化的时候，如何画曲线是比较麻烦的事情。不如一开始就直接用三角形mesh来近似一个球，最后也只需要画直线。所以光栅化是近似的，用三角形来近似。
* 对于光线追踪，我们并不需要对每个物体进行变换等操作。可以直接给出其表达式，然后我们**从成像面（也就是光栅化中的zNear）的每个像素出发发射一根光线，去数学计算这根光线会跟哪些物体相碰撞，从而求和得到该像素的颜色值**。先抛开光学的近似，光线追踪的效果是更接近真实的(可以说几乎完美)。因为不再需要用三角形近似物体(可以直接给出表达式)，光线也不再只能反射一次。
  * 说从成像面的每个像素出发发射一根光线，其实应该是在view空间中，该像素在zNear面的对应位置上发射一根光线。所以也要给出竖直视角和宽高比
